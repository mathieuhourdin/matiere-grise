import{u as D,r as n,y as h,O as i,Q as B,Z as b}from"./index-7b431e64.js";const{launchSnackbar:u}=B(),{user:g}=D(),o=n([]),t=n(null),L=n(null),d=n(null),p=n(null),f=n(null),y=n([]),_=n([]),m=n(!1),E=n(!1),k=n(!1),$=n(!1);async function F(e={}){var r;const{setLoading:a=!0,autoSelect:s=!0}=e;if(console.log("[useLens] loadUserLenses called, user:",g.value),!((r=g.value)!=null&&r.id))return console.warn("[useLens] User not found, skipping loadUserLenses"),[];a&&(m.value=!0);try{console.log("[useLens] Fetching lenses for user:",g.value.id);const l=await i.get(`/users/${g.value.id}/lens`);if(o.value=l.data,console.log("[useLens] Lenses loaded:",o.value),s&&o.value.length>0){const c=[...o.value].sort((P,T)=>{const C=new Date(P.updated_at||P.created_at||0).getTime();return new Date(T.updated_at||T.created_at||0).getTime()-C});console.log("[useLens] Auto-selecting most recently updated lens:",c[0]),U(c[0])}return o.value}catch(l){return console.error("Error loading lenses:",l),u(`Error loading lenses: ${l}`,"error"),[]}finally{a&&(m.value=!1)}}async function v(e,a="head"){E.value=!0;try{const s=await i.get(`/analysis/${e}`);return a==="head"?d.value=s.data:f.value=s.data,s.data}catch(s){console.error("Error fetching landmark analysis:",s),u(`Error fetching landmark analysis: ${s}`,"error"),a==="head"?d.value=null:f.value=null}finally{E.value=!1}}function U(e){t.value=e}function x(e){p.value=e,console.log("[useLens] Updated display landscape analysis ID to:",e)}async function O(e){var a;if(!((a=t.value)!=null&&a.id)){console.warn("[useLens] No current lens, cannot update current trace");return}try{await i.put(`/lens/${t.value.id}`,{target_trace_id:e}),console.log("[useLens] Updated lens current trace to:",e),await N(t.value.id)}catch(s){console.error("Error updating lens current trace:",s),u(`Error updating lens: ${s}`,"error")}}async function A(e){const a=t.value;if(!(a!=null&&a.id)){console.warn("[useLens] No current lens, cannot update processing state");return}try{const s={...a,processing_state:e};await i.put(`/lens/${a.id}`,s),console.log("[useLens] Updated lens processing_state to:",e),await N(a.id)}catch(s){console.error("Error updating lens processing state:",s),u(`Error updating lens: ${s}`,"error")}}async function Q(e){var a;if(!((a=g.value)!=null&&a.id)){console.warn("[useLens] User not found, cannot create lens");return}try{const r=(await i.post("/lens",{target_trace_id:e})).data;o.value=[...o.value,r],U(r),console.log("[useLens] Created lens for trace:",e)}catch(s){console.error("Error creating lens:",s),u(`Error creating lens: ${s}`,"error")}}const V=e=>new Promise(a=>setTimeout(a,e)),W=async e=>{var l;const a=e??((l=t.value)==null?void 0:l.id);if(!a)return null;const r=(await F({setLoading:!1,autoSelect:!1})).find(c=>c.id===a)??null;return r&&(t.value=r),r},Y=async()=>{const e=L.value,a=p.value,s=[];e&&s.push(v(e,"head")),a&&s.push(v(a,"display")),s.length>0&&await Promise.all(s)};let w=0;const N=async(e,a=1e3,s=Number.POSITIVE_INFINITY)=>{const r=++w;for(let l=0;l<s;l++){if(await V(a),r!==w)return null;const c=await W(e);if((c==null?void 0:c.processing_state)==="fnsh")return await b(),await Y(),c}return null};async function Z(e){var a;try{await i.delete(`/lens/${e}`),o.value=o.value.filter(s=>s.id!==e),((a=t.value)==null?void 0:a.id)===e&&(t.value=null),u("Lens supprimÃ©e","success")}catch(s){console.error("Error deleting lens:",s),u(`Erreur lors de la suppression: ${s}`,"error")}}h(t,e=>{console.log("[useLens] currentLens changed:",e),e&&e.current_landscape_id?(console.log("[useLens] Setting headLandscapeAnalysisId to:",e.current_landscape_id),L.value=e.current_landscape_id,p.value=e.current_landscape_id):(console.log("[useLens] No current_landscape_id, clearing state"),L.value=null,d.value=null,p.value=null,f.value=null)});h(L,async e=>{console.log("[useLens] headLandscapeAnalysisId changed:",e),e?await v(e,"head"):d.value=null});h(p,async e=>{console.log("[useLens] displayLandscapeAnalysisId changed:",e),e?await v(e,"display"):f.value=null});async function S(e){k.value=!0;try{const a=await i.get(`/analysis/${e}/landmarks`);return y.value=a.data,a.data}catch(a){console.error("Error fetching landmarks:",a),u(`Error fetching landmarks: ${a}`,"error"),y.value=[]}finally{k.value=!1}}async function I(e){$.value=!0;try{const a=await i.get(`/analysis/${e}/parents`);return _.value=a.data,a.data}catch(a){console.error("Error fetching landscape analysis parents:",a),u(`Error fetching landscape analysis parents: ${a}`,"error"),_.value=[]}finally{$.value=!1}}h(d,async e=>{console.log("[useLens] headLandscapeAnalysis changed:",e),e!=null&&e.id?(console.log("[useLens] Fetching parents for analysis:",e.id),await I(e.id)):_.value=[]});h(f,async e=>{console.log("[useLens] displayLandscapeAnalysis changed:",e),e!=null&&e.id?(console.log("[useLens] Fetching landmarks for analysis:",e.id),await S(e.id)):y.value=[]});function z(){return{lenses:o,currentLens:t,headLandscapeAnalysisId:L,headLandscapeAnalysis:d,displayLandscapeAnalysisId:p,displayLandscapeAnalysis:f,displayLandmarks:y,headLandscapeAnalysisParents:_,isLoadingLenses:m,isLoadingAnalysis:E,isLoadingLandmarks:k,isLoadingParents:$,loadUserLenses:F,selectLens:U,deleteLens:Z,fetchLandscapeAnalysis:v,fetchLandmarksForAnalysis:S,fetchLandscapeAnalysisParents:I,updateDisplayLandscapeAnalysis:x,updateLensCurrentTrace:O,updateLensProcessingState:A,createLens:Q}}export{z as u};
